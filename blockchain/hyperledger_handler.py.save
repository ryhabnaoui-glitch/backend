import os
import subprocess
import json
import logging
eimport time
from typing import Optional, Dict, Any, List

logger = logging.getLogger('EnhancedHyperledgerHandler')

class EnhancedHyperledgerHandler:
    def __init__(self, network_path: Optional[str] = None, channel_name: Optional[str] = None):
        self.network_path = network_path or os.getenv('FABRIC_NETWORK_PATH', '/opt/fabric-samples/test-network')
        self.channel_name = channel_name or 'mychannel'
        self.chaincode_name = 'voting'
        
       # In the __init__ method, change these lines:
        self.peer_address = os.getenv('CORE_PEER_ADDRESS', '172.19.0.3:7051')  # ← Use IP
        self.orderer_address = os.getenv('ORDERER_ADDRESS', '172.19.0.4:7050')  # ← Use IP
        
        self.fabric_env = os.environ.copy()
        self.fabric_env.update({
            'PATH': f"{self.network_path}/../bin:{os.environ.get('PATH', '')}",
            'FABRIC_CFG_PATH': f"{self.network_path}/../config",
            'CORE_PEER_TLS_ENABLED': 'false',
            'CORE_PEER_LOCALMSPID': 'Org1MSP',
            'CORE_PEER_MSPCONFIGPATH': f"{self.network_path}/organizations/peerOrganizations/org1.example.com/users/Admin@org1.example.com/msp",
            'CORE_PEER_ADDRESS': self.peer_address,
        })
        
        print(f"🚀 HYPERLEDGER HANDLER INITIALIZED (WSL DOCKER)")
        print(f"   Network Path: {self.network_path}")
        print(f"   Channel: {self.channel_name}")
        print(f"   Chaincode: {self.chaincode_name}")
        print(f"   Peer: {self.peer_address}")
        print(f"   Orderer: {self.orderer_address}")
        print(f"   TLS: DISABLED")
        
    def _execute_command(self, command: List[str], retries: int = 3, delay: int = 2) -> Dict[str, Any]:
        full_command = ['peer', 'chaincode'] + command
        
        print(f"🔧 EXECUTING COMMAND: {' '.join(full_command)}")
        print(f"🔧 Working directory: {self.network_path}")
        print(f"🔧 Peer address: {self.peer_address}")
        print(f"🔧 Orderer address: {self.orderer_address}")
        
        for attempt in range(retries):
            try:
                print(f"🔄 Attempt {attempt + 1}/{retries}: Running peer command...")
                
                result = subprocess.run(
                    full_command,
                    check=True,
                    stdout=subprocess.PIPE,
                    stderr=subprocess.PIPE,
                    text=True,
                    timeout=60,
                    cwd=self.network_path,
                    env=self.fabric_env
                )
                
                print(f"✅ COMMAND SUCCEEDED!")
                print(f"📤 STDOUT: {result.stdout}")
                if result.stderr:
                    print(f"⚠️ STDERR: {result.stderr}")
                
                if result.stdout.strip():
                    try:
                        parsed_result = json.loads(result.stdout.strip())
                        print(f"📊 PARSED JSON RESULT: {parsed_result}")
                        return parsed_result
                    except json.JSONDecodeError:
                        print(f"📝 RAW TEXT RESULT: {result.stdout.strip()}")
                        return {'output': result.stdout.strip(), 'success': True}
                else:
                    print(f"✅ EMPTY RESPONSE (SUCCESS)")
                    return {'success': True, 'output': 'OK'}
                    
            except subprocess.CalledProcessError as e:
                print(f"❌ COMMAND FAILED with exit code: {e.returncode}")
                print(f"📤 STDOUT: {e.stdout}")
                print(f"📤 STDERR: {e.stderr}")
                
                if attempt < retries - 1:
                    print(f"⏳ Waiting {delay} seconds before retry...")
                    time.sleep(delay)
                else:
                    error_msg = f"Command failed after {retries} attempts: {e.stderr}"
                    print(f"💥 FINAL FAILURE: {error_msg}")
                    raise Exception(error_msg)
                    
            except subprocess.TimeoutExpired as e:
                print(f"⏰ COMMAND TIMEOUT after 60 seconds")
                if attempt < retries - 1:
                    print(f"⏳ Waiting {delay} seconds before retry...")
                    time.sleep(delay)
                else:
                    raise Exception(f"Command timed out after {retries} attempts")
                    
            except Exception as e:
                print(f"❌ UNEXPECTED ERROR: {e}")
                if attempt < retries - 1:
                    print(f"⏳ Waiting {delay} seconds before retry...")
                    time.sleep(delay)
                else:
                    raise Exception(f"Unexpected command failure: {str(e)}")
    
    def cast_vote(self, election_id: str, candidate_id: str, voter_id: str) -> Dict[str, Any]:
        try:
            print(f"=== HYPERLEDGER VOTING DEBUG ===")
            print(f"User: ryhab1 (ID: {voter_id})")
            print(f"Election: election (DB ID: {election_id})")
            print(f"Election ID for Hyperledger: {election_id}")
            print(f"Candidate ID: {candidate_id}")
            print(f"Voter ID: {voter_id}")
            print(f"================================")
            
            print(f"\n🗳️ ========== CASTING HYPERLEDGER VOTE ==========")
            print(f"   Election ID: {election_id}")
            print(f"   Candidate ID: {candidate_id}")
            print(f"   Voter ID: {voter_id}")
            
            timestamp = str(int(time.time()))
            print(f"   Timestamp: {timestamp}")
            
            response = self._invoke_chaincode(
                'CastVote',
                [str(election_id), str(candidate_id), str(voter_id), timestamp]
            )
            
            print(f"✅ VOTE CAST SUCCESSFULLY!")
            print(f"📊 RESPONSE: {response}")
            
            result = {
                'electionId': election_id,
                'candidateId': candidate_id,
                'transactionId': f'hlf_vote_{election_id}_{candidate_id}_{voter_id}_{int(time.time())}',
                'timestamp': int(time.time()),
                'success': True,
                'response': response
            }
            
            print(f"🎯 FINAL RESULT: {result}")
            return result
            
        except Exception as e:
            print(f"❌ VOTE CASTING FAILED: {e}")
            import traceback
            traceback.print_exc()
            raise Exception(f"Hyperledger voting failed: {str(e)}")
    
    def has_user_voted(self, election_id: str, voter_id: str) -> bool:
        try:
            print(f"\n🔍 ========== CHECKING VOTE STATUS ==========")
            print(f"   Election ID: {election_id}")
            print(f"   Voter ID: {voter_id}")
            
            response = self._query_chaincode('HasVoted', [str(election_id), str(voter_id)])
            
            print(f"📊 HAS VOTED RESPONSE: {response}")
            
            if isinstance(response, dict):
                output = response.get('output', '').strip().lower()
            else:
                output = str(response).strip().lower()
            
            result = output == 'true'
            print(f"🎯 HAS VOTED RESULT: {result}")
            
            return result
            
        except Exception as e:
            print(f"❌ CHECK VOTE FAILED: {e}")
            import traceback
            traceback.print_exc()
            return False
    
    def get_election_results(self, election_id: str) -> Dict[str, Any]:
        try:
            print(f"\n📊 ========== GETTING ELECTION RESULTS ==========")
            print(f"   Election ID: {election_id}")
            
            response = self._query_chaincode('GetResults', [str(election_id)])
            
            print(f"🎯 GET RESULTS RAW RESPONSE: {response}")
            
            if isinstance(response, dict):
                if 'output' in response:
                    try:
                        result = json.loads(response['output'])
                        print(f"✅ PARSED RESULTS FROM OUTPUT: {result}")
                        return result
                    except json.JSONDecodeError:
                        print(f"⚠️ Could not parse JSON from output: {response['output']}")
                        return {'candidates': [], 'totalVotes': 0, 'error': 'parse_failed'}
                else:
                    print(f"✅ DIRECT DICT RESULTS: {response}")
                    return response
            elif isinstance(response, str):
                try:
                    result = json.loads(response)
                    print(f"✅ PARSED STRING RESULTS: {result}")
                    return result
                except json.JSONDecodeError:
                    print(f"⚠️ Could not parse JSON from string: {response}")
                    return {'candidates': [], 'totalVotes': 0, 'error': 'parse_failed'}
            else:
                print(f"⚠️ UNEXPECTED RESPONSE TYPE: {type(response)}")
                return {'candidates': [], 'totalVotes': 0, 'error': 'unexpected_type'}
                
        except Exception as e:
            print(f"❌ GET RESULTS FAILED: {e}")
            import traceback
            traceback.print_exc()
            return {'candidates': [], 'totalVotes': 0, 'error': str(e)}
    
    def _invoke_chaincode(self, function: str, args: List[str]) -> Dict[str, Any]:
        print(f"\n🚀 ========== INVOKING CHAINCODE ==========")
        print(f"   Function: {function}")
        print(f"   Args: {args}")
        
        chaincode_args = json.dumps({'function': function, 'Args': args})
        print(f"📋 Chaincode JSON: {chaincode_args}")
        
        command = [
            'invoke',
            '-o', self.orderer_address,
            '--peerAddresses', self.peer_address,
            '-C', self.channel_name,
            '-n', self.chaincode_name,
            '-c', chaincode_args
        ]
        
        print(f"🔧 INVOKE COMMAND: {command}")
        return self._execute_command(command)
    
    def _query_chaincode(self, function: str, args: List[str]) -> Dict[str, Any]:
        print(f"\n🔍 ========== QUERYING CHAINCODE ==========")
        print(f"   Function: {function}")
        print(f"   Args: {args}")
        
        chaincode_args = json.dumps({'function': function, 'Args': args})
        print(f"📋 Query JSON: {chaincode_args}")
        
        command = [
            'query',
            '-C', self.channel_name,
            '-n', self.chaincode_name,
            '-c', chaincode_args
        ]
        
        print(f"🔧 QUERY COMMAND: {command}")
        return self._execute_command(command)

    def create_election(self, title, description, start_time, end_time, creator_id):
        print(f"\n📝 ========== CREATE ELECTION ==========")
        print(f"⚠️ CreateElection function not available in this chaincode")
        print(f"   Title: {title}")
        print(f"   Description: {description}")
        
        return {
            'electionId': '1', 
            'transactionId': 'create_election_not_available', 
            'status': 'success',
            'message': 'CreateElection not implemented in chaincode'
        }
    
    def add_candidate(self, election_id, candidate_id, name, caller_id):
        print(f"\n👤 ========== ADD CANDIDATE ==========")
        print(f"⚠️ AddCandidate function not available in this chaincode")
        print(f"   Election ID: {election_id}")
        print(f"   Candidate ID: {candidate_id}")
        print(f"   Name: {name}")
        
        return {
            'candidateId': candidate_id, 
            'transactionId': 'add_candidate_not_available', 
            'status': 'success',
            'message': 'AddCandidate not implemented in chaincode'
        }
    
    def test_connection(self):
        try:
            print(f"\n🧪 ========== TESTING CONNECTION ==========")
            print(f"   Network Path: {self.network_path}")
            print(f"   Peer: {self.peer_address}")
            print(f"   Orderer: {self.orderer_address}")
            print(f"   Channel: {self.channel_name}")
            
            result = self._query_chaincode('ping', [])
            print(f"✅ CONNECTION TEST SUCCESSFUL: {result}")
            return True
            
        except Exception as e:
            print(f"❌ CONNECTION TEST FAILED: {e}")
            return False
